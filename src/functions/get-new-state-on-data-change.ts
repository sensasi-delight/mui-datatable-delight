// vendors
import { isValidElement, type RefObject } from 'react'
// globals
import type { DataTableProps } from '@src/data-table.props'
import type {
    DataTableOptions,
    DataTableSortOrderOption
} from '@src/types/options'
import type { DataTableState } from '@src/types/state'
import type { HandleUpdateCellValue } from '@src/hooks/use-data-table-context/components/provider/types/handle-update-cell-value'
import { getCollatorComparator } from './get-collator-comparator'
import { warnDeprecated } from './warn-deprecated'
import buildColumns from './build-columns'
import getDisplayData from './get-new-state-on-data-change/get-display-data'
import sortTable from './sort-table'
import transformData from './transform-data'
import type { DataItemState } from '@src/types/state/data-item'
import type { Primitive } from '@src/types/values/primitive'

enum TABLE_LOAD {
    INITIAL = 1,
    UPDATE = 2
}

/**
 * ⚠️ This JSDoc is generated by AI ⚠️
 * -
 *
 * Builds a new state object based on the latest props. This includes generating
 * the filterData, filterList, and displayData based on the columns, data, and
 * options.
 *
 * @param props - The properties of the data table.
 * @param status - The status of the data table.
 * @param dataUpdated - A boolean indicating whether the data has been updated.
 * @param options - Configuration options for the data table.
 * @param state - The current state of the data table.
 * @returns The updated state of the data table.
 */
export default function getNewStateOnDataChange<T>(
    props: {
        columns: DataTableProps<T>['columns']
        options: DataTableProps<T>['options']
    },
    dataParam: T[] | DataItemState[],
    status: TABLE_LOAD,
    dataUpdated: boolean,
    options: DataTableOptions<T>,
    state: DataTableState<T>,
    updateCellValueRef: RefObject<HandleUpdateCellValue | undefined>
): DataTableState<T> {
    const { columns, filterData, filterList, columnOrder } = buildColumns<T>(
        props.columns,
        state.columns,
        options.columnOrder,
        state.columnOrder
    )

    let sortIndex: number | null = null
    let sortDirection: DataTableSortOrderOption['direction'] = 'none'

    const data =
        status === TABLE_LOAD.INITIAL
            ? transformData(columns, dataParam as T[], options)
            : dataParam

    const rowsPerPage = options.rowsPerPage ?? state.rowsPerPage
    const page = options.page ?? state.page
    const sortOrder = options.sortOrder ?? state.sortOrder

    let tableData: DataTableState<T>['data'] = []

    columns.forEach((column, colIndex) => {
        for (let rowIndex = 0; rowIndex < data.length; rowIndex++) {
            /**
             * IF status === TABLE_LOAD.INITIAL rowDataOrStateData should be T
             * IF status === TABLE_LOAD.UPDATE rowDataOrStateData should be DataItemState
             */
            const rowDataOrStateData = data[rowIndex]

            if (!rowDataOrStateData) {
                throw new Error('rowDataOrStateData is undefined')
            }

            let value: unknown

            const isInit =
                status === TABLE_LOAD.INITIAL &&
                Array.isArray(rowDataOrStateData)

            if (isInit) {
                value = rowDataOrStateData[colIndex]
            } else if (
                typeof rowDataOrStateData === 'object' &&
                'data' in rowDataOrStateData
            ) {
                value = rowDataOrStateData?.data[colIndex]
            }

            if (typeof tableData[rowIndex] === 'undefined') {
                if (isInit) {
                    tableData.push({
                        index: rowIndex,
                        data: rowDataOrStateData
                    })
                } else if (
                    typeof rowDataOrStateData === 'object' &&
                    'data' in rowDataOrStateData
                ) {
                    tableData.push(rowDataOrStateData)
                }
            }

            if (column.filter !== false) {
                if (typeof column.customBodyRender === 'function') {
                    const funcResult = column.customBodyRender(
                        value,
                        rowIndex,
                        colIndex,
                        state,
                        () => undefined
                    )

                    if (
                        isValidElement(funcResult) &&
                        typeof funcResult.props === 'object' &&
                        funcResult.props &&
                        'value' in funcResult.props
                    ) {
                        value = funcResult.props?.value
                    } else if (typeof funcResult === 'string') {
                        value = funcResult
                    }
                }

                if (
                    typeof value === 'object' &&
                    !Array.isArray(value) &&
                    value !== null
                ) {
                    value = value.toString ? value.toString() : ''
                }

                if (
                    !filterData[colIndex]?.includes(value as Primitive) &&
                    !Array.isArray(value)
                ) {
                    filterData[colIndex]?.push(value as Primitive)
                } else if (Array.isArray(value)) {
                    value.forEach(element => {
                        let elmVal: string

                        if (
                            (typeof element === 'object' && element !== null) ||
                            typeof element === 'function'
                        ) {
                            elmVal = element.toString ? element.toString() : ''
                        } else {
                            elmVal = element
                        }

                        if (!filterData[colIndex]?.includes(elmVal)) {
                            filterData[colIndex]?.push(elmVal)
                        }
                    })
                }
            }
        }

        if (column.filterOptions) {
            if (Array.isArray(column.filterOptions)) {
                filterData[colIndex] = column.filterOptions
                warnDeprecated(
                    'filterOptions must now be an object. see https://github.com/gregnb/mui-datatables/tree/master/examples/customize-filter example'
                )
            } else if (Array.isArray(column.filterOptions.names)) {
                filterData[colIndex] = column.filterOptions.names
            }
        }

        if (column.filterList) {
            filterList[colIndex] = column.filterList
        } else if ((state.filterList[colIndex]?.length ?? 0) > 0) {
            const tempFilterList = state.filterList[colIndex]

            if (!tempFilterList) {
                throw new Error('filterList must be an array')
            }

            filterList[colIndex] = tempFilterList
        }

        if (options.sortFilterList) {
            const comparator = getCollatorComparator()

            // @ts-expect-error  WILL FIX THIS LATER
            filterData[colIndex]?.sort(comparator)
        }

        if (column.name === sortOrder?.name) {
            sortDirection = sortOrder?.direction
            sortIndex = colIndex
        }
    })

    let selectedRowsData: DataTableState<T>['selectedRows'] = {
        data: [],
        lookup: {}
    }

    let expandedRowsData: DataTableState<T>['expandedRows'] = {
        data: [],
        lookup: {}
    }

    if (status === TABLE_LOAD.INITIAL) {
        if (
            options.rowsSelected?.length &&
            options.selectableRows === 'multiple'
        ) {
            options.rowsSelected
                .filter(
                    selectedRowIndex =>
                        selectedRowIndex === 0 ||
                        (Number(selectedRowIndex) && selectedRowIndex > 0)
                )
                .forEach(row => {
                    let rowPos = row

                    for (
                        let cIndex = 0;
                        cIndex < state.displayData.length;
                        cIndex++
                    ) {
                        if (state.displayData[cIndex]?.dataIndex === row) {
                            rowPos = cIndex
                            break
                        }
                    }

                    selectedRowsData.data.push({
                        index: rowPos,
                        dataIndex: row
                    })
                    selectedRowsData.lookup[row] = true
                })
        } else if (
            options.rowsSelected &&
            options.rowsSelected.length === 1 &&
            options.selectableRows === 'single'
        ) {
            const dataIndex = options.rowsSelected[0] ?? -1

            let rowPos = dataIndex

            for (let cIndex = 0; cIndex < state.displayData.length; cIndex++) {
                if (state.displayData[cIndex]?.dataIndex === dataIndex) {
                    rowPos = cIndex

                    break
                }
            }

            selectedRowsData.data.push({
                index: rowPos,
                dataIndex
            })

            selectedRowsData.lookup[dataIndex] = true
        } else if (
            options.rowsSelected &&
            options.rowsSelected.length > 1 &&
            options.selectableRows === 'single'
        ) {
            console.error(
                'Multiple values provided for selectableRows, but selectableRows set to "single". Either supply only a single value or use "multiple".'
            )
        } else if (
            typeof options.rowsSelected === 'undefined' &&
            dataUpdated === false
        ) {
            if (state.selectedRows) {
                selectedRowsData = { ...state.selectedRows }
            }
        }

        if (options.rowsExpanded?.length && options.expandableRows) {
            options.rowsExpanded.forEach(row => {
                let rowPos = row

                for (
                    let cIndex = 0;
                    cIndex < state.displayData.length;
                    cIndex++
                ) {
                    if (state.displayData[cIndex]?.dataIndex === row) {
                        rowPos = cIndex
                        break
                    }
                }

                expandedRowsData.data.push({
                    index: rowPos,
                    dataIndex: row
                })
                expandedRowsData.lookup[row] = true
            })
        } else if (
            typeof options.rowsExpanded === 'undefined' &&
            dataUpdated === false &&
            state.expandedRows
        ) {
            expandedRowsData = { ...state.expandedRows }
        }
    }

    if (!options.serverSide && sortIndex !== null) {
        const sortedData = sortTable(
            tableData,
            sortIndex,
            sortDirection,
            columns[sortIndex],
            options,
            state
        )

        tableData = sortedData.data
    }

    const searchText =
        status === TABLE_LOAD.INITIAL
            ? (options?.searchText ?? state.searchText)
            : state.searchText

    const newState: DataTableState<T> = {
        ...state,
        count: options.count ?? tableData.length,
        columnOrder,
        columns,
        expandedRows: expandedRowsData,
        data: tableData,
        filterData,
        filterList,
        page,
        rowsPerPage,
        searchText,
        selectedRows: selectedRowsData,
        sortOrder
    }

    return {
        ...newState,
        displayData: getDisplayData(
            columns,
            tableData,
            filterList,
            searchText,
            newState,
            options,
            updateCellValueRef
        )
    }
}
